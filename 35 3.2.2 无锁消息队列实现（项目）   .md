自选锁和互斥锁会进行标记。

#### lock-free,wait-free以及blocking

![image-20260120154612701](35 3.2.2 无锁消息队列实现（项目）   .assets/image-20260120154612701.png)

#### 什么时候使用无锁？

先用有锁进行实现
然后分析，是否需要保证系统向前移动
用无锁进行优化
还有执行任务时间，耗时计算或耗时1o,选择有锁

#### 只能使用无锁队列的情况：

1.信号处理程序 不能使用blocking
2.实时系统

#### 生产者消费者队列

![image-20260120160200969](35 3.2.2 无锁消息队列实现（项目）   .assets/image-20260120160200969.png)

![image-20260120160604025](35 3.2.2 无锁消息队列实现（项目）   .assets/image-20260120160604025.png)

![image-20260120161933853](35 3.2.2 无锁消息队列实现（项目）   .assets/image-20260120161933853.png)

####  支持什么数量类型的生产者和消费者

![image-20260120165944334](35 3.2.2 无锁消息队列实现（项目）   .assets/image-20260120165944334.png)

#### 多生产者多消费者

![image-20260120170149705](35 3.2.2 无锁消息队列实现（项目）   .assets/image-20260120170149705.png)

##### 优化

![image-20260120170645859](35 3.2.2 无锁消息队列实现（项目）   .assets/image-20260120170645859.png)



#### 避免生产者和消费者发生碰撞 

2个链表，减少写的线程之间发生碰撞，从而提升效率

![image-20260120171200965](35 3.2.2 无锁消息队列实现（项目）   .assets/image-20260120171200965.png)

#### 锁的耗时

![image-20260120172033858](35 3.2.2 无锁消息队列实现（项目）   .assets/image-20260120172033858.png)

![image-20260120172432662](35 3.2.2 无锁消息队列实现（项目）   .assets/image-20260120172432662.png)

#### 非侵入式

#### main

![image-20260120172500343](35 3.2.2 无锁消息队列实现（项目）   .assets/image-20260120172500343.png)

![image-20260120172516939](35 3.2.2 无锁消息队列实现（项目）   .assets/image-20260120172516939.png)

 linkoff从count节点偏移多少字节就是用于连接下一个节点的指针

#### 无锁队列 MPSCQueue

侵入式的直接作为节点的一部分，非侵入式的往里插入节点。

![image-20260120184633955](35 3.2.2 无锁消息队列实现（项目）   .assets/image-20260120184633955.png)

#### 入队

![image-20260120184610579](35 3.2.2 无锁消息队列实现（项目）   .assets/image-20260120184610579.png)

![image-20260120185657187](35 3.2.2 无锁消息队列实现（项目）   .assets/image-20260120185657187.png)

#### 出队

![image-20260120192257630](35 3.2.2 无锁消息队列实现（项目）   .assets/image-20260120192257630.png)

![image-20260120223758406](35 3.2.2 无锁消息队列实现（项目）   .assets/image-20260120223758406.png)