# 周报
***
## 本周学习内容（React）

### 一，组件通信
概念：组件通信就是组件之间的数据传递，根据组件嵌套关系的不同，有不同的通信方法。
1. 父子通信<br>实现步骤
   1. 父组件传递数据-在子组件标签上绑定数据
   2. 子组件接受数据-子组件通过props参数接受数据
```javascript
//定义子组件
function Son(props){
    //props：对象包含了父组件传递过来的所有的数据
    console.log(props)//控制台打印出props对象{name: "this is name"}
    return <div>
        {props.name},
        {props.age},
        jsx: {props.child}
    </div>//利用jsx: jsx语法，将props对象中的child属性值渲染到页面中
}

function App(){
    const name = 'this is name'
    return (
        /*实现组件父子嵌套*/
        <div>
            <Son name = {name} age={18} child={<div>this is child div</div>}/>
        </div>
    )
    
}
```
##### props说明
1. props可以转递任意的数据包括jsx
2. props是只读对象,子组件只能读取props中的数据,不能直接进行修改,父组件的数据只能由父组件修改

##### 子传父实现
核心思路: 在子组件中调用父组件中的函数并传递参数
```javascript
function Son({ onGetSonMsg }){
    const sonMsg = 'this is son msg'
    return <div>
        <button onClick={()=>{onGetSonMsg(sonMsg)}}>send msg to father</button>
    </div>//点击按钮时调用父组件中的函数并传递参数sonMsg
}
function App(){
    const getMsg = (msg)=>{console.log(msg)}
    return (
        <div>
            <Son onGetSonMsg = {getMsg}/>
        </div>
    )
}
```
2. 使用状态提升实现兄弟组件通信
```javascript
function A ({onGetAMsg}){
    const aMsg = 'this is A component'
    return <div>
        <p>this is A component</p>
        <button onClick={()=>onGetAMsg(aMsg)}>send msa to B</button>
    </div>
}
function B (props){
    const [bMsg,setBMsg] = useState('this is B component')
    return <div>
        <p>{bMsg}</p>
        <button onClick={()=>{setBMsg(props.msg)}}>accept msg from A</button>
    </div>
}
function App(){
    const [Msg,setMsg] = useState('')
    const getAMsg = (msg)=>{
        console.log(msg)
        setMsg(msg)
    }
    return (
        <div>
            <A onGetAMsg = {getAMsg}/>
            <B msg={Msg}</>
        </div>
    )
}
```
## 二,自定义Hook函数
概念：自定义 Hook 是一个复用有状态逻辑的函数，它允许我们将组件逻辑提取到可重用的函数中。
1. 实现步骤
   1. 创建自定义 Hook 函数 - 函数名必须以 use 开头
   2. 在 Hook 中使用 React 的状态和生命周期相关的 Hook
   3. 返回需要共享的状态和操作函数
```javascript
// 定义自定义 Hook
function useCounter(initialValue = 0) {
    const [count, setCount] = useState(initialValue);
    
    const increment = () => setCount(count + 1);
    const decrement = () => setCount(count - 1);
    const reset = () => setCount(initialValue);
    
    // 返回状态和操作函数
    return {
        count,
        increment,
        decrement,
        reset
    };
}

function Counter() {
    // 使用自定义 Hook
    const { count, increment, decrement, reset } = useCounter(0);
    
    return (
        <div>
            <h2>Count: {count}</h2>
            <button onClick={increment}>+</button>
            <button onClick={decrement}>-</button>
            <button onClick={reset}>Reset</button>
        </div>
    );
}

function App() {
    return (
        <div>
            <Counter />
        </div>
    )
}

```
##### 自定义Hook说明
1. 命名规范：自定义 Hook 必须以 use 开头，这样 ESLint 插件才能识别其中的 Hook 规则
2. 逻辑复用：自定义 Hook 解决了组件间逻辑复用的问题，但不复用 state 本身
3. 每次调用独立：每次调用自定义 Hook 都会创建独立的 state 和副作用

## 三,复习了一下jQuery的用法
* $()选择器
* 层级选择器
  ```javascript
  $("parent > child") // 子元素
  $("ancestor descendant") // 后代
  $("prev + next")    // 相邻兄弟
  $("prev ~ siblings") // 后续兄弟
  ```
* 过滤选择器
  ```javascript
  $("li:first")      // 第一个
  $("li:last")       // 最后一个
  $("li:even")       // 偶数索引
  $("li:odd")        // 奇数索引
  $("li:eq(2)")      // 索引等于2
  $("li:gt(2)")      // 大于2
  $("li:lt(2)")      // 小于2
  $(":not(selector)") // 排除
  $(":hidden")       // 隐藏元素
  $(":visible")      // 可见元素
  ```
* DOM操作
* 事件处理
* 动画效果
* 等.....
## 下周计划
继续学习React